# 后端模块功能

## 0. maven配置阿里云镜像仓库

```xml
 <!--发现依赖和扩展的远程仓库列表。 -->
  <repositories>
    <repository>
      <!--远程仓库唯一标识符。可以用来匹配在settings.xml文件里配置的远程仓库 -->
      <id>nexus-aliyun</id>
      <!--远程仓库名称 -->
      <name>Nexus aliyun</name>
      <!--远程仓库URL，按protocol://hostname/path形式 -->
      <url>http://maven.aliyun.com/nexus/content/groups/public</url>
    </repository>
  </repositories>
 <!--在maven的setting.xml的mirrors下复制-->
<!-- 阿里云仓库 -->
    <mirror>
        <id>alimaven</id>
        <mirrorOf>central</mirrorOf>
        <name>aliyun maven</name>
        <url>http://maven.aliyun.com/nexus/content/repositories/central/</url>
    </mirror>
    <!-- 中央仓库1 -->
    <mirror>
        <id>repo1</id>
        <mirrorOf>central</mirrorOf>
        <name>Human Readable Name for this Mirror.</name>
        <url>http://repo1.maven.org/maven2/</url>
    </mirror>
    <!-- 中央仓库2 -->
    <mirror>
        <id>repo2</id>
        <mirrorOf>central</mirrorOf>
        <name>Human Readable Name for this Mirror.</name>
        <url>http://repo2.maven.org/maven2/</url>
    </mirror>
```



## 1.极光短信接口

```xml
  <!--极光接口-->
    <dependency>
      <groupId>cn.jpush.api</groupId>
      <artifactId>jiguang-common</artifactId>
      <version>1.0.8</version>
    </dependency>
    <dependency>
      <groupId>cn.jpush.api</groupId>
      <artifactId>jsms-client</artifactId>
      <version>1.2.9</version>
    </dependency>
    <dependency>
      <groupId>com.google.code.gson</groupId>
      <artifactId>gson</artifactId>
      <version>2.3</version>
    </dependency>
    <dependency>
      <groupId>org.slf4j</groupId>
      <artifactId>slf4j-api</artifactId>
      <version>1.7.7</version>
    </dependency>

```

```java
import cn.jiguang.common.resp.APIConnectionException;
import cn.jiguang.common.resp.APIRequestException;
import cn.jsms.api.SendSMSResult;
import cn.jsms.api.common.SMSClient;
import cn.jsms.api.common.model.SMSPayload;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException; 
 
@Component //交给spring管理
public class JGSmsUtil {
 
    // masterSecret https://www.jiguang.cn/dev2/#/overview/appCardList 开发者服务--->应用设置--->应用信息--> Master Secret
    public String masterSecret = "xxxx";
 
    //appKey https://www.jiguang.cn/dev2/#/overview/appCardList 开发者服务--->应用设置--->应用信息--> Master Secret
    public String appKey = "xxxxx";
 
    //初始化发短信客户端
    private SMSClient smsClient = new SMSClient(masterSecret, appKey);
 
    /**
     * 发送模板短信-验证码 示例1
     *
     * @param phoneNumber
     * create 2019/12/26 by kingyifan
     */
    public void sendSMSCode(String phoneNumber, String code) {
        try {//构建发送短信
            SMSPayload payload = SMSPayload.newBuilder()
                    .setMobileNumber(phoneNumber) // 手机号码
                    .setTempId(1)            // 短信模板ID 需要自行申请 模板id为：1的则自带验证码模板id
                    .addTempPara("code", code)  // key模板参数value：参数值  您的手机验证码：{{code}}，有效期5分钟，请勿泄露。如非本人操作，请忽略此短信。谢谢！
                    .setSignId(xxxx)// 签名id 需要自行申请审核。个人也可以申请
                    .build();
 
            //发送短信 会返回msg_id
            SendSMSResult res = smsClient.sendTemplateSMS(payload);
            //执行业务/
            //指向保存短信发送记录业务逻辑 可以直接扔到MQ
            /**
             * 第一个参数极光返回的消息id
             * 第二个发送的手机号
             * 第三个发送内容
             * 第四个发送时间
             * 保存到DB
             */
            //insertSendSmsLog(res.getMessageId(),phoneNumber,code,0,System.currentTimeMillis()/1000);
            //执行业务/
 
        } catch (APIConnectionException e) {
            e.printStackTrace();
        } catch (APIRequestException e) {
            e.printStackTrace();
        }
    }
 
    /**
     * 发送模板短信-取快递 示例2
     *
     * @param phoneNumber 手机号
     * @param name        名字
     * @param address     地址
     *                    <p>
     *                    create 2019/12/26 by kingyifan
     */
    public void sendSMSOther(String name, String address, String phoneNumber) {
        try {
            SMSPayload payload = SMSPayload.newBuilder()
                    .setMobileNumber(phoneNumber) // 手机号码
                    .setTempId(xxxx)            // 短信模板ID 需要自行申请
                    .addTempPara("name", name)  // key模板参数value：参数值  尊敬的{{name}}，您的快递到{{address}}，请速来取一下。
                    .addTempPara("address", address)  // key模板参数value：参数值  尊敬的{{name}}，您的快递到{{address}}，请速来取一下。
                    .setSignId(xxxx)// 签名id 需要自行申请审核。个人也可以申请
                    .build();
 
            //发送短信
            SendSMSResult res = smsClient.sendTemplateSMS(payload);
            //执行业务/
            //指向保存短信发送记录业务逻辑 可以直接扔到MQ
            /**
             * 第一个参数极光返回的消息id
             * 第二个发送的手机号
             * 第三个发送内容
             * 第四个发送时间
             * 保存到DB
             */
            //insertSendSmsLog(res.getMessageId(),phoneNumber,code,0,System.currentTimeMillis()/1000);
            //执行业务/
        } catch (APIConnectionException e) {
            e.printStackTrace();
        } catch (APIRequestException e) {
            e.printStackTrace();
        }
    }
 
    /**
     * SHA1加密
     *
     * @param strSrc 明文
     * @return 加密之后的密文
     */
    public static String encrypt(String strSrc) {
        MessageDigest md = null;
        String strDes = null;
        byte[] bt = strSrc.getBytes();
        try {
            md = MessageDigest.getInstance("SHA-1");// 将此换成SHA-1、SHA-512、SHA-384等参数
            md.update(bt);
            strDes = bytes2Hex(md.digest()); // to HexString
        } catch (NoSuchAlgorithmException e) {
            return null;
        }
        return strDes;
    }
 
    /**
     * byte数组转换为16进制字符串
     *
     * @param bts 数据源
     * @return 16进制字符串
     */
    private static String bytes2Hex(byte[] bts) {
        String des = "";
        String tmp = null;
        for (int i = 0; i < bts.length; i++) {
            tmp = (Integer.toHexString(bts[i] & 0xFF));
            if (tmp.length() == 1) {
                des += "0";
            }
            des += tmp;
        }
        return des;
    }
 
    /**
     * 延签判断是否是极光回调
     *
     * @param signature
     * @param nonce
     * @param timestamp
     * @return create kingyifan by  on 2019.12.26
     */
    public Boolean checkSign(String signature, String nonce, String timestamp) {
        //加密进行比对
        String str = String.format("appKey=%s&appMasterSecret=%s&nonce=%s×tamp=%s",
                appKey, masterSecret, nonce, timestamp);
        String new_signature = encrypt(str);
        if (signature.equals(new_signature)) {
            return true;
        }
        return false;
    }
}

```

## 2.阿里云短信接口

```xml
    <dependency>
            <groupId>com.aliyun</groupId>
            <artifactId>aliyun-java-sdk-core</artifactId>
            <version>4.5.3</version>
```

```properties
#用户名
sms.username =
#密码
sms.password =
#接收人手机号,多个手机号用英文逗号隔开
sms.toPhone=13536299557
#变量名
sms.sign =code
#短信模板
sms.template=
```

```java
import com.aliyuncs.CommonRequest;
import com.aliyuncs.CommonResponse;
import com.aliyuncs.DefaultAcsClient;
import com.aliyuncs.IAcsClient;
import com.aliyuncs.exceptions.ClientException;
import com.aliyuncs.exceptions.ServerException;
import com.aliyuncs.http.MethodType;
import com.aliyuncs.profile.DefaultProfile;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

@Component
public class SMSUtil {
    @Value("${sms.username}")
    private String username;
    @Value("${sms.password}")
    private String password;
    @Value("${sms.toPhone}")
    private String toPhone;
    @Value("${sms.sign}")
    private String sign;
    @Value("${sms.template}")
    private String template;
        public  void  sendsms() {
            DefaultProfile profile = DefaultProfile.getProfile("cn-hangzhou", username, password);
            IAcsClient client = new DefaultAcsClient(profile);
            /*固定写法*/
            CommonRequest request = new CommonRequest();
            request.setSysMethod(MethodType.POST);
            request.setSysDomain("dysmsapi.aliyuncs.com");
            request.setSysVersion("2017-05-25");
            request.setSysAction("SendSms");
            request.putQueryParameter("RegionId", "cn-hangzhou");
            /*创建短信*/
            //接收人手机号,多个手机号用英文逗号隔开
            request.putQueryParameter("PhoneNumbers", toPhone);
            //标签名（变量名）
            request.putQueryParameter("SignName", sign);
            //短信模板
            request.putQueryParameter("TemplateCode", template);
             //短信模板变量名
            String str = String.valueOf(new Random().nextInt(899999) + 100000);
            int code = Integer.parseInt(str);
            request.putQueryParameter("TemplateParam", "{\"code\":\"" + code + "\"}");
            try {
                CommonResponse response = client.getCommonResponse(request);
                System.out.println(response.getData());
            } catch (ServerException e) {
                e.printStackTrace();
            } catch (ClientException e) {
                e.printStackTrace();
            }
    }
}
```

## 3.邮箱发送接口

```xml
<dependency>
            <groupId>javax.activation</groupId>
            <artifactId>activation</artifactId>
            <version>1.1</version>
        </dependency>
        <dependency>
            <groupId>javax.mail</groupId>
            <artifactId>mail</artifactId>
            <version>1.4.7</version>
        </dependency>
//spring-content-support.jar
```

```properties
#邮箱配置
mail.host=smtp.qq.com
mail.username=1324747110@qq.com
mail.password=
mail.protocol=smtp
#默认465/587      25端口被阿里云禁用
mail.port=465
mail.default=UTF-8
mail.properties.mail.smtp.auth= true
mail.properties.mail.smtp.timeout=5000
mail.properties.mail.smtp.ssl.enable=true
email.default.to=1324747110@qq.com,1076127198@qq.com,1195317391@qq.com
email.default.subject=Hello
#邮箱发送开关
email.switch=false
```

```java
import freemarker.template.Template;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.mail.javamail.MimeMessageHelper;
import org.springframework.stereotype.Component;
import org.springframework.ui.freemarker.FreeMarkerTemplateUtils;
import org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer;

import javax.mail.MessagingException;
import javax.mail.internet.MimeMessage;
import java.util.HashMap;
import java.util.Map;

@Component
public class MailUtils {
    @Value("${mail.username}")
    private String from;
    @Value("${email.default.to}")
    private String[] to;
    @Value("${email.default.subject}")
    private String subject;
    @Value("${email.switch}")
    private boolean b;

    @Autowired
    private JavaMailSender mailSender;

    @Autowired
    private FreeMarkerConfigurer freeMarkerConfigurer;

    private static final String ENCODING = "utf-8";
    public void setFreeMarkerConfigurer(FreeMarkerConfigurer freeMarkerConfigurer) {
        this.freeMarkerConfigurer = freeMarkerConfigurer;
    }

    public void sendMail() throws MessagingException {
        if(b==true){
            //创建邮件
            MimeMessage  message = mailSender.createMimeMessage();
            try {
                //设置
                MimeMessageHelper helper = new MimeMessageHelper(message, true,"utf8");
                //用于接收邮件的邮箱
                helper.setTo(to);
                //邮件的主题
                helper.setSubject(subject);
                //发送人
                helper.setFrom(from);
                //邮件的正文,true为打开html文本邮件
                Map<String, Object> model = new HashMap<>();
                model.put("href","http://www.baidu.com");
                model.put("name","系统管理员");
                model.put("content","您有新的订单，请及时处理！！");
                Template template =freeMarkerConfigurer.getConfiguration().getTemplate("mail.ftl");
                String html = FreeMarkerTemplateUtils.processTemplateIntoString(template,model);
                helper.setText(html,true);
                //发送邮件
                mailSender.send(message);
                System.out.println("邮件发送成功...");
            } catch (Exception e) {
                throw new MessagingException("failed to send mail!", e);
            }
        }else{
            System.out.println("发送功能已关闭！");
        }

    }
}
```

## 4.  Shiro的角色权限认证及登录拦截

```xml
 <!--shiro-->
      <dependency>
        <groupId>org.apache.shiro</groupId>
        <artifactId>shiro-core</artifactId>
        <version>1.2.2</version>
      </dependency>
      <dependency>
        <groupId>org.apache.shiro</groupId>
        <artifactId>shiro-web</artifactId>
        <version>1.2.2</version>
      </dependency>
      <dependency>
        <groupId>org.apache.shiro</groupId>
        <artifactId>shiro-ehcache</artifactId>
        <version>1.2.2</version>
      </dependency>
      <dependency>
        <groupId>org.apache.shiro</groupId>
        <artifactId>shiro-quartz</artifactId>
        <version>1.2.2</version>
      </dependency>
      <dependency>
        <groupId>org.apache.shiro</groupId>
        <artifactId>shiro-spring</artifactId>
        <version>1.2.2</version>
      </dependency>
      <!--shiro-thymeleaf-->
      <dependency>
        <groupId>com.github.theborakompanioni</groupId>
        <artifactId>thymeleaf-extras-shiro</artifactId>
        <version>2.0.0</version>
      </dependency>
      <!--themeleaf模板-->
      <dependency>
        <groupId>org.thymeleaf</groupId>
        <artifactId>thymeleaf-spring5</artifactId>
        <version>3.0.11.RELEASE</version>
      </dependency>
```

```xml
  <!-- shiro-enchange.xml-->
<?xml version="1.0" encoding="UTF-8" ?>
<ehcache updateCheck="false" dynamicConfig="false">
    <diskStore path="C:\TEMP" />

    <cache name="user" timeToLiveSeconds="300" maxEntriesLocalHeap="1000" />

    <defaultCache name="defaultCache"
                  maxElementsInMemory="10000"
                  eternal="false"
                  timeToIdleSeconds="120"
                  timeToLiveSeconds="120"
                  overflowToDisk="false"
                  maxElementsOnDisk="100000"
                  diskPersistent="false"
                  diskExpiryThreadIntervalSeconds="120"
                  memoryStoreEvictionPolicy="LRU"
    />
    <!-- 缓存淘汰策略：当缓存紧张是，删除一些老缓存数据
        LRU：最近最少使用
        FIFO：先进先出
        LFU：最少使用
     -->
</ehcache>
```

```xml
   <!-- spring-shiro.xml-->
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd">


    <!-- 配置 Shiro 的 SecurityManager Bean. -->
    <bean id="securityManager" class="org.apache.shiro.web.mgt.DefaultWebSecurityManager">
        <property name="cacheManager" ref="cacheManager"/>
        <property name="realm" ref="myRealm"/>
        <property name="sessionMode" value="native"/>
        <property name="rememberMeManager" ref="rememberMeManager"/>
    </bean>

    <!-- 配置缓存管理器 -->
    <bean id="cacheManager" class="org.apache.shiro.cache.ehcache.EhCacheManager">
        <!-- 指定 ehcache 的配置文件 -->
        <property name="cacheManagerConfigFile" value="classpath:ehcache-shiro.xml"/>
    </bean>

    <!-- 自定义配置进行授权和认证的 Realm -->
    <bean id="myRealm" class="com.frame.modules.shiro.MyRealm">
<!--        <property name="credentialsMatcher" ref="credentialMatcher"></property>-->
        <property name="workerService" ref="workerServiceImpl"></property>
    </bean>
  <!--  &lt;!&ndash;凭证匹配器&ndash;&gt;
    <bean id="credentialMatcher" class="org.apache.shiro.authc.credential.HashedCredentialsMatcher">
        <property name="hashAlgorithmName" value="md5"></property>
        <property name="hashSalted" value="1"></property>
    </bean>-->

    <!--记住我-->
    <bean id="rememberMeCookie" class="org.apache.shiro.web.servlet.SimpleCookie">
        <constructor-arg value="rememberMe"/><!--接收参数-->
        <property name="httpOnly" value="true"/><!--防止跨域攻击-->
        <property name="maxAge" value="604800"/> <!--以秒为单位，cookie过期设置为七天-->
    </bean>
    <!--记住我管理器-->
    <bean id="rememberMeManager" class="org.apache.shiro.web.mgt.CookieRememberMeManager">
        <property name="cookie" ref="rememberMeCookie"></property>
    </bean>
    <!-- 启用shrio授权注解拦截方式,id必须和web.xml中DelegatingFilterProxy的filter-name一致-->
    <bean id="shiroFilter" class="org.apache.shiro.spring.web.ShiroFilterFactoryBean">
        <!-- 装配 securityManager -->
        <property name="securityManager" ref="securityManager"/>
        <!-- 配置登陆页面 -->
        <property name="loginUrl" value="/login"/>
        <!-- 登陆成功后的页面 -->
        <property name="successUrl" value="/success"/>
        <!--没权限时跳转页面-->
        <property name="unauthorizedUrl" value="/unauthorized"/>
        <!-- 具体配置需要拦截哪些 URL, 以及访问对应的 URL 时使用 Shiro 的什么 Filter 进行拦截.  -->
       <!-- anon：无需认证（登陆）可以访问
        * 		authc：必须认证才可以访问
        * 		user： 如果使用rememberMe功能可以直接访问
        * 		perms：该资源必须得到资源权限才可以访问
        * 		roles：该资源必须得到角色权限才可以访问-->
        <property name="filterChainDefinitions">
            <value>
                <!--权限拦截及报错释放-->
                /error404 = anon
                /unauthorized = anon
                <!--释放静态资源-->
                /static/** = anon
                <!--登录及注销-->
                /logout = logout
                /login = anon
 <!--               &lt;!&ndash;角色菜单授权&ndash;&gt;
                /worker/index = perms["manager:worker"]
                /permission/index = perms["manager:permission"]-->
                <!--菜单权限授权-->
                <!--用户-->
          <!--      /worker/add = perms["user:add"]
                /worker/update = perms["user:update"]
                /worker/delete = perms["user:delete"]-->
                <!--拦截所有-->
                /** = user
                /** = authc
            </value>
        </property>
    </bean>
    <!--拦截无权限错误页面-->
    <bean class="org.springframework.web.servlet.handler.SimpleMappingExceptionResolver">
        <property name="exceptionMappings">
            <props>
                <prop key="org.apache.shiro.authz.UnauthorizedException">/unauthorized</prop>
            </props>
        </property>
    </bean>
    <!-- 自定义异常处理-->
    <bean id="exceptionResolver" class="com.frame.modules.component.MyExceptionResolver"></bean>
    <!-- 使用thymeleaf解析 -->
    <bean id="templateResolver"
          class="org.thymeleaf.spring5.templateresolver.SpringResourceTemplateResolver">
        <property name="prefix" value="/WEB-INF/views/" />
        <property name="suffix" value=".html" />
        <property name="templateMode" value="HTML" />
        <property name="cacheable" value="false" />
    </bean>
    <bean id="shiroDialect" class="at.pollux.thymeleaf.shiro.dialect.ShiroDialect"/>
    <bean id="templateEngine" class="org.thymeleaf.spring5.SpringTemplateEngine">
        <property name="templateResolvers" ref="templateResolver" />
        <property name="additionalDialects" ref="shiroDialect" />
    </bean>
       <!-- 开启Shiro注解 start -->
    <bean id="lifecycleBeanPostProcessor" class="org.apache.shiro.spring.LifecycleBeanPostProcessor" />
    <!-- 开启Shiro注解 end -->
    <bean class="org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator" depends-on="lifecycleBeanPostProcessor" />
    <!-- 配置授权属性 -->
    <bean class="org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor">
        <property name="securityManager" ref="securityManager"></property>
    </bean>
</beans>
```

```xml
 <!--web.xml -->
 <!-- shiro filter start -->
  <filter>
    <filter-name>shiroFilter</filter-name>
    <filter-class>
      org.springframework.web.filter.DelegatingFilterProxy
    </filter-class>
    <init-param>
      <param-name>targetFilterLifecycle</param-name>
      <param-value>true</param-value>
    </init-param>
  </filter>
  <filter-mapping>
    <filter-name>shiroFilter</filter-name>
    <url-pattern>/*</url-pattern>
  </filter-mapping>
  <!-- shiro filter end -->
```

```java
package com.frame.modules.shiro;

import com.frame.modules.common.Constast;
import com.frame.modules.dao.PermissionMapper;
import com.frame.modules.dao.RoleMapper;
import com.frame.modules.dao.WorkerMapper;
import com.frame.modules.pojo.Worker;
import com.frame.modules.service.PermissionService;
import com.frame.modules.service.RoleService;
import com.frame.modules.service.WorkerService;
import org.apache.shiro.authc.*;
import java.util.Set;
import org.apache.shiro.authz.AuthorizationInfo;
import org.apache.shiro.authz.SimpleAuthorizationInfo;
import org.apache.shiro.realm.AuthorizingRealm;
import org.apache.shiro.subject.PrincipalCollection;
import org.springframework.beans.factory.annotation.Autowired;

public class MyRealm extends AuthorizingRealm{
    @Autowired
    private WorkerService workerService;
    @Autowired
    private RoleService roleService;
    @Autowired
    private PermissionService permissionService;


    public void setWorkerService(WorkerService workerService) {
        this.workerService = workerService;
    }
    /*用户授权类*/
    @Override
    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) {
        System.out.println("执行授权逻辑");
        //获取用户名
        String username = (String)principalCollection.iterator().next();
        //根据用户名获取用户角色
        Set<String> rolename = roleService.queryRoleNameByUserName(username);
        //根据用户名获取用户权限(set 可以去掉重复对象)
       Set<String> ps= permissionService.queryPermissionByUserName(username);
        //给资源进行授权
        SimpleAuthorizationInfo info = new SimpleAuthorizationInfo();
        info.setRoles(rolename);
        info.addStringPermissions(ps);
        return info;
    }

    /*用户认证类*/
    @Override
    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken arg0) throws AuthenticationException {
        System.out.println("用户认证开始");
        //编写shiro判断逻辑，判断用户名和密码
        //从token中获取用户名密码
        UsernamePasswordToken token = (UsernamePasswordToken) arg0;
        //从token中获取用户名
        String username = token.getUsername();
        //从token中获取密码
        char[] password = token.getPassword();
        //密码转字符串
        String pwd = password.toString();
        //匹配用户名
        Worker worker = workerService.findByUsernameAndUserpassword(username);

        //如果身份信息不正确则返回null,shiro会自动各跑出UnknownAccountException
        //用户名错误
        if(worker == null) {
            throw new UnknownAccountException();
        }else {
            worker.setLoginstatus("0");
        }
        //密码错误
        if(worker.getPassword() == pwd ){
            throw new IncorrectCredentialsException();
        }
        // 帐号锁定
        if (worker.getStatus() == Constast.Lock ) {
            throw new LockedAccountException();
        }
        //判断密码
        return new SimpleAuthenticationInfo(username, worker.getPassword(), getName());
    }

}

```

## 5.汉语转全拼

```java
import net.sourceforge.pinyin4j.PinyinHelper;
import net.sourceforge.pinyin4j.format.HanyuPinyinCaseType;
import net.sourceforge.pinyin4j.format.HanyuPinyinOutputFormat;
import net.sourceforge.pinyin4j.format.HanyuPinyinToneType;
import net.sourceforge.pinyin4j.format.HanyuPinyinVCharType;
import net.sourceforge.pinyin4j.format.exception.BadHanyuPinyinOutputFormatCombination;
import java.io.UnsupportedEncodingException;

public class ChineseCharToEnUtils {
    /**
     * 得到 全拼
     *
     * @param src
     * @return
     */
    public static String getPingYin(String src) {
        char[] t1 = null;
        t1 = src.toCharArray();
        String[] t2 = new String[t1.length];
        HanyuPinyinOutputFormat t3 = new HanyuPinyinOutputFormat();
        t3.setCaseType(HanyuPinyinCaseType.LOWERCASE);
        t3.setToneType(HanyuPinyinToneType.WITHOUT_TONE);
        t3.setVCharType(HanyuPinyinVCharType.WITH_V);
        String t4 = "";
        int t0 = t1.length;
        try {
            for (int i = 0; i < t0; i++) {
                // 判断是否为汉字字符
                if (java.lang.Character.toString(t1[i]).matches("[\\u4E00-\\u9FA5]+")) {
                    t2 = PinyinHelper.toHanyuPinyinStringArray(t1[i], t3);
                    t4 += t2[0];
                } else {
                    t4 += java.lang.Character.toString(t1[i]);
                }
            }
            return t4;
        } catch (BadHanyuPinyinOutputFormatCombination e1) {
            e1.printStackTrace();
        }
        return t4;
    }
    /**
     * 得到中文首字母
     *
     * @param str
     * @return
     */
    public static String getPinYinHeadChar(String str) {

        String convert = "";
        for (int j = 0; j < str.length(); j++) {
            char word = str.charAt(j);
            String[] pinyinArray = PinyinHelper.toHanyuPinyinStringArray(word);
            if (pinyinArray != null) {
                convert += pinyinArray[0].charAt(0);
            } else {
                convert += word;
            }
        }
        return convert;
    }

```

## 6.office转pdf接口

```xml
<!--maven依赖convert doc-->
        <dependency>
            <groupId>com.documents4j</groupId>
            <artifactId>documents4j-local</artifactId>
            <version>1.0.3</version>
        </dependency>
        <dependency>
            <groupId>com.documents4j</groupId>
            <artifactId>documents4j-transformer-msoffice-word</artifactId>
            <version>1.0.3</version>
        </dependency>
```

```java
 /**
     * convert方法 接受参数 java.io.File 或 java.io.InputStream
     * to方法 接受参数 java.io.File 或 java.io.OutputStream
     *
     * @param sourceFile
     * @param tarPdfFile
     */
    public void toPdf(String sourceFile, String tarPdfFile,String realname,BufferedOutputStream water) {
        try {
            InputStream docxInputStream = new FileInputStream(sourceFile);
            OutputStream outputStream = new FileOutputStream(tarPdfFile);
            IConverter converter = LocalConverter.builder().build();
            converter.convert(docxInputStream).as(DocumentType.DOCX).to(outputStream).
                as(DocumentType.PDF).execute();
            outputStream.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
```



## 7.pdf自定义加水印接口

```xml
   <!-- https://mvnrepository.com/artifact/com.itextpdf/itext-asian -->
        <dependency>
            <groupId>com.itextpdf</groupId>
            <artifactId>itext-asian</artifactId>
            <version>5.2.0</version>
        </dependency>

        <!-- https://mvnrepository.com/artifact/com.itextpdf/itextpdf -->
        <dependency>
            <groupId>com.itextpdf</groupId>
            <artifactId>itextpdf</artifactId>
            <version>5.4.4</version>
        </dependency>
```



```java
 /**
     *
     * @param bos 输出目录
     * @param input pdf原始目录
     * @param waterMarkName  水印标签
     * @throws DocumentException
     * @throws IOException
     */
    public static void setWatermark(BufferedOutputStream bos, String input, String waterMarkName)
            throws DocumentException, IOException {
        PdfReader reader = new PdfReader(input, "PDF".getBytes());
        PdfStamper stamper = new PdfStamper(reader, bos);
        int total = reader.getNumberOfPages() + 1;
        PdfContentByte content;
        BaseFont base = BaseFont.createFont("STSong-Light", "UniGB-UCS2-H", BaseFont.EMBEDDED);
        PdfGState gs = new PdfGState();
        for (int i = 1; i < total; i++) {
            // 在内容上方加水印
            content = stamper.getOverContent(i);
            //在内容下方加水印
            // content = stamper.getUnderContent(i);
            //水印透明度
            gs.setFillOpacity(0.5f);
            gs.setStrokeOpacity(0.5f);
            content.setGState(gs);
            content.beginText();
            content.setFontAndSize(base, 20);
            content.setTextMatrix(70, 200);
            //居中显示
            content.showTextAligned(Element.ALIGN_CENTER, waterMarkName, 320, 350, 55);
            content.endText();
        }
        stamper.close();

    }
```



# 前端模块功能

## 1.头像引用地址在线预览功能

```html
                <!--头像预览-->
                <div style="display:none" id="displayHead" class="displayHead">
                    <div class="user-info-head" >
                        <img id="header" src="" alt=""/>
                    </div>
                </div>
<div class="layui-form-item">
    <label class="layui-form-label layui-form-required">头像:</label>
     <div class="layui-input-inline" style="width: 400px">
     <input name="avatar"  placeholder="请使用正确的头像引用地址(url)" value="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=158071645,1972277985&fm=26&gp=0.jpg" class="layui-input" lay-verify="required" required/>
     </div>
    <!--点击跳转头像预览-->
<button class="layui-btn layui-btn-sm layui-btn-normal" id="display">头像预览</button >
  </div>
```

```js
 $('#display').on('click', function(data){
            layer.open({
                type: 1, //0（信息框，默认）1（页面层）2（iframe层）3（加载层）4（tips层）。
                title: false,
                anim: 5,
                area : ['120px' , '120px'],
                content:  $('#displayHead'),
                success:function () {
                    $("#header").attr("src",$('input[name=avatar]').val());
                }
            });
            return false;
        })
```

