# 后端模块功能

## 0. maven配置阿里云镜像仓库

```xml
 <!--发现依赖和扩展的远程仓库列表。 -->
  <repositories>
    <repository>
      <!--远程仓库唯一标识符。可以用来匹配在settings.xml文件里配置的远程仓库 -->
      <id>nexus-aliyun</id>
      <!--远程仓库名称 -->
      <name>Nexus aliyun</name>
      <!--远程仓库URL，按protocol://hostname/path形式 -->
      <url>http://maven.aliyun.com/nexus/content/groups/public</url>
    </repository>
  </repositories>
 <!--在maven的setting.xml的mirrors下复制-->
<!-- 阿里云仓库 -->
    <mirror>
        <id>alimaven</id>
        <mirrorOf>central</mirrorOf>
        <name>aliyun maven</name>
        <url>http://maven.aliyun.com/nexus/content/repositories/central/</url>
    </mirror>
    <!-- 中央仓库1 -->
    <mirror>
        <id>repo1</id>
        <mirrorOf>central</mirrorOf>
        <name>Human Readable Name for this Mirror.</name>
        <url>http://repo1.maven.org/maven2/</url>
    </mirror>
    <!-- 中央仓库2 -->
    <mirror>
        <id>repo2</id>
        <mirrorOf>central</mirrorOf>
        <name>Human Readable Name for this Mirror.</name>
        <url>http://repo2.maven.org/maven2/</url>
    </mirror>
```



## 1.极光短信接口

```xml
  <!--极光接口-->
    <dependency>
      <groupId>cn.jpush.api</groupId>
      <artifactId>jiguang-common</artifactId>
      <version>1.0.8</version>
    </dependency>
    <dependency>
      <groupId>cn.jpush.api</groupId>
      <artifactId>jsms-client</artifactId>
      <version>1.2.9</version>
    </dependency>
    <dependency>
      <groupId>com.google.code.gson</groupId>
      <artifactId>gson</artifactId>
      <version>2.3</version>
    </dependency>
    <dependency>
      <groupId>org.slf4j</groupId>
      <artifactId>slf4j-api</artifactId>
      <version>1.7.7</version>
    </dependency>

```

```java
import cn.jiguang.common.resp.APIConnectionException;
import cn.jiguang.common.resp.APIRequestException;
import cn.jsms.api.SendSMSResult;
import cn.jsms.api.common.SMSClient;
import cn.jsms.api.common.model.SMSPayload;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException; 
 
@Component //交给spring管理
public class JGSmsUtil {
 
    // masterSecret https://www.jiguang.cn/dev2/#/overview/appCardList 开发者服务--->应用设置--->应用信息--> Master Secret
    public String masterSecret = "xxxx";
 
    //appKey https://www.jiguang.cn/dev2/#/overview/appCardList 开发者服务--->应用设置--->应用信息--> Master Secret
    public String appKey = "xxxxx";
 
    //初始化发短信客户端
    private SMSClient smsClient = new SMSClient(masterSecret, appKey);
 
    /**
     * 发送模板短信-验证码 示例1
     *
     * @param phoneNumber
     * create 2019/12/26 by kingyifan
     */
    public void sendSMSCode(String phoneNumber, String code) {
        try {//构建发送短信
            SMSPayload payload = SMSPayload.newBuilder()
                    .setMobileNumber(phoneNumber) // 手机号码
                    .setTempId(1)            // 短信模板ID 需要自行申请 模板id为：1的则自带验证码模板id
                    .addTempPara("code", code)  // key模板参数value：参数值  您的手机验证码：{{code}}，有效期5分钟，请勿泄露。如非本人操作，请忽略此短信。谢谢！
                    .setSignId(xxxx)// 签名id 需要自行申请审核。个人也可以申请
                    .build();
 
            //发送短信 会返回msg_id
            SendSMSResult res = smsClient.sendTemplateSMS(payload);
            //执行业务/
            //指向保存短信发送记录业务逻辑 可以直接扔到MQ
            /**
             * 第一个参数极光返回的消息id
             * 第二个发送的手机号
             * 第三个发送内容
             * 第四个发送时间
             * 保存到DB
             */
            //insertSendSmsLog(res.getMessageId(),phoneNumber,code,0,System.currentTimeMillis()/1000);
            //执行业务/
 
        } catch (APIConnectionException e) {
            e.printStackTrace();
        } catch (APIRequestException e) {
            e.printStackTrace();
        }
    }
 
    /**
     * 发送模板短信-取快递 示例2
     *
     * @param phoneNumber 手机号
     * @param name        名字
     * @param address     地址
     *                    <p>
     *                    create 2019/12/26 by kingyifan
     */
    public void sendSMSOther(String name, String address, String phoneNumber) {
        try {
            SMSPayload payload = SMSPayload.newBuilder()
                    .setMobileNumber(phoneNumber) // 手机号码
                    .setTempId(xxxx)            // 短信模板ID 需要自行申请
                    .addTempPara("name", name)  // key模板参数value：参数值  尊敬的{{name}}，您的快递到{{address}}，请速来取一下。
                    .addTempPara("address", address)  // key模板参数value：参数值  尊敬的{{name}}，您的快递到{{address}}，请速来取一下。
                    .setSignId(xxxx)// 签名id 需要自行申请审核。个人也可以申请
                    .build();
 
            //发送短信
            SendSMSResult res = smsClient.sendTemplateSMS(payload);
            //执行业务/
            //指向保存短信发送记录业务逻辑 可以直接扔到MQ
            /**
             * 第一个参数极光返回的消息id
             * 第二个发送的手机号
             * 第三个发送内容
             * 第四个发送时间
             * 保存到DB
             */
            //insertSendSmsLog(res.getMessageId(),phoneNumber,code,0,System.currentTimeMillis()/1000);
            //执行业务/
        } catch (APIConnectionException e) {
            e.printStackTrace();
        } catch (APIRequestException e) {
            e.printStackTrace();
        }
    }
 
    /**
     * SHA1加密
     *
     * @param strSrc 明文
     * @return 加密之后的密文
     */
    public static String encrypt(String strSrc) {
        MessageDigest md = null;
        String strDes = null;
        byte[] bt = strSrc.getBytes();
        try {
            md = MessageDigest.getInstance("SHA-1");// 将此换成SHA-1、SHA-512、SHA-384等参数
            md.update(bt);
            strDes = bytes2Hex(md.digest()); // to HexString
        } catch (NoSuchAlgorithmException e) {
            return null;
        }
        return strDes;
    }
 
    /**
     * byte数组转换为16进制字符串
     *
     * @param bts 数据源
     * @return 16进制字符串
     */
    private static String bytes2Hex(byte[] bts) {
        String des = "";
        String tmp = null;
        for (int i = 0; i < bts.length; i++) {
            tmp = (Integer.toHexString(bts[i] & 0xFF));
            if (tmp.length() == 1) {
                des += "0";
            }
            des += tmp;
        }
        return des;
    }
 
    /**
     * 延签判断是否是极光回调
     *
     * @param signature
     * @param nonce
     * @param timestamp
     * @return create kingyifan by  on 2019.12.26
     */
    public Boolean checkSign(String signature, String nonce, String timestamp) {
        //加密进行比对
        String str = String.format("appKey=%s&appMasterSecret=%s&nonce=%s×tamp=%s",
                appKey, masterSecret, nonce, timestamp);
        String new_signature = encrypt(str);
        if (signature.equals(new_signature)) {
            return true;
        }
        return false;
    }
}

```

## 2.阿里云短信接口

```xml
    <dependency>
            <groupId>com.aliyun</groupId>
            <artifactId>aliyun-java-sdk-core</artifactId>
            <version>4.5.3</version>
```

```properties
#用户名
sms.username =
#密码
sms.password =
#接收人手机号,多个手机号用英文逗号隔开
sms.toPhone=13536299557
#变量名
sms.sign =code
#短信模板
sms.template=
```

```java
import com.aliyuncs.CommonRequest;
import com.aliyuncs.CommonResponse;
import com.aliyuncs.DefaultAcsClient;
import com.aliyuncs.IAcsClient;
import com.aliyuncs.exceptions.ClientException;
import com.aliyuncs.exceptions.ServerException;
import com.aliyuncs.http.MethodType;
import com.aliyuncs.profile.DefaultProfile;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

@Component
public class SMSUtil {
    @Value("${sms.username}")
    private String username;
    @Value("${sms.password}")
    private String password;
    @Value("${sms.toPhone}")
    private String toPhone;
    @Value("${sms.sign}")
    private String sign;
    @Value("${sms.template}")
    private String template;
        public  void  sendsms() {
            DefaultProfile profile = DefaultProfile.getProfile("cn-hangzhou", username, password);
            IAcsClient client = new DefaultAcsClient(profile);
            /*固定写法*/
            CommonRequest request = new CommonRequest();
            request.setSysMethod(MethodType.POST);
            request.setSysDomain("dysmsapi.aliyuncs.com");
            request.setSysVersion("2017-05-25");
            request.setSysAction("SendSms");
            request.putQueryParameter("RegionId", "cn-hangzhou");
            /*创建短信*/
            //接收人手机号,多个手机号用英文逗号隔开
            request.putQueryParameter("PhoneNumbers", toPhone);
            //标签名（变量名）
            request.putQueryParameter("SignName", sign);
            //短信模板
            request.putQueryParameter("TemplateCode", template);
             //短信模板变量名
            String str = String.valueOf(new Random().nextInt(899999) + 100000);
            int code = Integer.parseInt(str);
            request.putQueryParameter("TemplateParam", "{\"code\":\"" + code + "\"}");
            try {
                CommonResponse response = client.getCommonResponse(request);
                System.out.println(response.getData());
            } catch (ServerException e) {
                e.printStackTrace();
            } catch (ClientException e) {
                e.printStackTrace();
            }
    }
}
```

## 3.邮箱发送接口

```xml
<dependency>
            <groupId>javax.activation</groupId>
            <artifactId>activation</artifactId>
            <version>1.1</version>
        </dependency>
        <dependency>
            <groupId>javax.mail</groupId>
            <artifactId>mail</artifactId>
            <version>1.4.7</version>
        </dependency>
//spring-content-support.jar
```

```properties
#邮箱配置
mail.host=smtp.qq.com
mail.username=1324747110@qq.com
mail.password=
mail.protocol=smtp
#默认465/587      25端口被阿里云禁用
mail.port=465
mail.default=UTF-8
mail.properties.mail.smtp.auth= true
mail.properties.mail.smtp.timeout=5000
mail.properties.mail.smtp.ssl.enable=true
email.default.to=1324747110@qq.com,1076127198@qq.com,1195317391@qq.com
email.default.subject=Hello
#邮箱发送开关
email.switch=false
```

```java
import freemarker.template.Template;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.mail.javamail.MimeMessageHelper;
import org.springframework.stereotype.Component;
import org.springframework.ui.freemarker.FreeMarkerTemplateUtils;
import org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer;

import javax.mail.MessagingException;
import javax.mail.internet.MimeMessage;
import java.util.HashMap;
import java.util.Map;

@Component
public class MailUtils {
    @Value("${mail.username}")
    private String from;
    @Value("${email.default.to}")
    private String[] to;
    @Value("${email.default.subject}")
    private String subject;
    @Value("${email.switch}")
    private boolean b;

    @Autowired
    private JavaMailSender mailSender;

    @Autowired
    private FreeMarkerConfigurer freeMarkerConfigurer;

    private static final String ENCODING = "utf-8";
    public void setFreeMarkerConfigurer(FreeMarkerConfigurer freeMarkerConfigurer) {
        this.freeMarkerConfigurer = freeMarkerConfigurer;
    }

    public void sendMail() throws MessagingException {
        if(b==true){
            //创建邮件
            MimeMessage  message = mailSender.createMimeMessage();
            try {
                //设置
                MimeMessageHelper helper = new MimeMessageHelper(message, true,"utf8");
                //用于接收邮件的邮箱
                helper.setTo(to);
                //邮件的主题
                helper.setSubject(subject);
                //发送人
                helper.setFrom(from);
                //邮件的正文,true为打开html文本邮件
                Map<String, Object> model = new HashMap<>();
                model.put("href","http://www.baidu.com");
                model.put("name","系统管理员");
                model.put("content","您有新的订单，请及时处理！！");
                Template template =freeMarkerConfigurer.getConfiguration().getTemplate("mail.ftl");
                String html = FreeMarkerTemplateUtils.processTemplateIntoString(template,model);
                helper.setText(html,true);
                //发送邮件
                mailSender.send(message);
                System.out.println("邮件发送成功...");
            } catch (Exception e) {
                throw new MessagingException("failed to send mail!", e);
            }
        }else{
            System.out.println("发送功能已关闭！");
        }

    }
}
```

## 4.  Shiro的角色权限认证及登录拦截

```xml
 <!--shiro-->
      <dependency>
        <groupId>org.apache.shiro</groupId>
        <artifactId>shiro-core</artifactId>
        <version>1.2.2</version>
      </dependency>
      <dependency>
        <groupId>org.apache.shiro</groupId>
        <artifactId>shiro-web</artifactId>
        <version>1.2.2</version>
      </dependency>
      <dependency>
        <groupId>org.apache.shiro</groupId>
        <artifactId>shiro-ehcache</artifactId>
        <version>1.2.2</version>
      </dependency>
      <dependency>
        <groupId>org.apache.shiro</groupId>
        <artifactId>shiro-quartz</artifactId>
        <version>1.2.2</version>
      </dependency>
      <dependency>
        <groupId>org.apache.shiro</groupId>
        <artifactId>shiro-spring</artifactId>
        <version>1.2.2</version>
      </dependency>
      <!--shiro-thymeleaf-->
      <dependency>
        <groupId>com.github.theborakompanioni</groupId>
        <artifactId>thymeleaf-extras-shiro</artifactId>
        <version>2.0.0</version>
      </dependency>
      <!--themeleaf模板-->
      <dependency>
        <groupId>org.thymeleaf</groupId>
        <artifactId>thymeleaf-spring5</artifactId>
        <version>3.0.11.RELEASE</version>
      </dependency>
```

```xml
  <!-- shiro-enchange.xml-->
<?xml version="1.0" encoding="UTF-8" ?>
<ehcache updateCheck="false" dynamicConfig="false">
    <diskStore path="C:\TEMP" />

    <cache name="user" timeToLiveSeconds="300" maxEntriesLocalHeap="1000" />

    <defaultCache name="defaultCache"
                  maxElementsInMemory="10000"
                  eternal="false"
                  timeToIdleSeconds="120"
                  timeToLiveSeconds="120"
                  overflowToDisk="false"
                  maxElementsOnDisk="100000"
                  diskPersistent="false"
                  diskExpiryThreadIntervalSeconds="120"
                  memoryStoreEvictionPolicy="LRU"
    />
    <!-- 缓存淘汰策略：当缓存紧张是，删除一些老缓存数据
        LRU：最近最少使用
        FIFO：先进先出
        LFU：最少使用
     -->
</ehcache>
```

```xml
   <!-- spring-shiro.xml-->
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd">


    <!-- 配置 Shiro 的 SecurityManager Bean. -->
    <bean id="securityManager" class="org.apache.shiro.web.mgt.DefaultWebSecurityManager">
        <property name="cacheManager" ref="cacheManager"/>
        <property name="realm" ref="myRealm"/>
        <property name="sessionMode" value="native"/>
        <property name="rememberMeManager" ref="rememberMeManager"/>
    </bean>

    <!-- 配置缓存管理器 -->
    <bean id="cacheManager" class="org.apache.shiro.cache.ehcache.EhCacheManager">
        <!-- 指定 ehcache 的配置文件 -->
        <property name="cacheManagerConfigFile" value="classpath:ehcache-shiro.xml"/>
    </bean>

    <!-- 自定义配置进行授权和认证的 Realm -->
    <bean id="myRealm" class="com.frame.modules.shiro.MyRealm">
<!--        <property name="credentialsMatcher" ref="credentialMatcher"></property>-->
        <property name="workerService" ref="workerServiceImpl"></property>
    </bean>
  <!--  &lt;!&ndash;凭证匹配器&ndash;&gt;
    <bean id="credentialMatcher" class="org.apache.shiro.authc.credential.HashedCredentialsMatcher">
        <property name="hashAlgorithmName" value="md5"></property>
        <property name="hashSalted" value="1"></property>
    </bean>-->

    <!--记住我-->
    <bean id="rememberMeCookie" class="org.apache.shiro.web.servlet.SimpleCookie">
        <constructor-arg value="rememberMe"/><!--接收参数-->
        <property name="httpOnly" value="true"/><!--防止跨域攻击-->
        <property name="maxAge" value="604800"/> <!--以秒为单位，cookie过期设置为七天-->
    </bean>
    <!--记住我管理器-->
    <bean id="rememberMeManager" class="org.apache.shiro.web.mgt.CookieRememberMeManager">
        <property name="cookie" ref="rememberMeCookie"></property>
    </bean>
    <!-- 启用shrio授权注解拦截方式,id必须和web.xml中DelegatingFilterProxy的filter-name一致-->
    <bean id="shiroFilter" class="org.apache.shiro.spring.web.ShiroFilterFactoryBean">
        <!-- 装配 securityManager -->
        <property name="securityManager" ref="securityManager"/>
        <!-- 配置登陆页面 -->
        <property name="loginUrl" value="/login"/>
        <!-- 登陆成功后的页面 -->
        <property name="successUrl" value="/success"/>
        <!--没权限时跳转页面-->
        <property name="unauthorizedUrl" value="/unauthorized"/>
        <!-- 具体配置需要拦截哪些 URL, 以及访问对应的 URL 时使用 Shiro 的什么 Filter 进行拦截.  -->
       <!-- anon：无需认证（登陆）可以访问
        * 		authc：必须认证才可以访问
        * 		user： 如果使用rememberMe功能可以直接访问
        * 		perms：该资源必须得到资源权限才可以访问
        * 		roles：该资源必须得到角色权限才可以访问-->
        <property name="filterChainDefinitions">
            <value>
                <!--权限拦截及报错释放-->
                /error404 = anon
                /unauthorized = anon
                <!--释放静态资源-->
                /static/** = anon
                <!--登录及注销-->
                /logout = logout
                /login = anon
 <!--               &lt;!&ndash;角色菜单授权&ndash;&gt;
                /worker/index = perms["manager:worker"]
                /permission/index = perms["manager:permission"]-->
                <!--菜单权限授权-->
                <!--用户-->
          <!--      /worker/add = perms["user:add"]
                /worker/update = perms["user:update"]
                /worker/delete = perms["user:delete"]-->
                <!--拦截所有-->
                /** = user
                /** = authc
            </value>
        </property>
    </bean>
    <!--拦截无权限错误页面-->
    <bean class="org.springframework.web.servlet.handler.SimpleMappingExceptionResolver">
        <property name="exceptionMappings">
            <props>
                <prop key="org.apache.shiro.authz.UnauthorizedException">/unauthorized</prop>
            </props>
        </property>
    </bean>
    <!-- 自定义异常处理-->
    <bean id="exceptionResolver" class="com.frame.modules.component.MyExceptionResolver"></bean>
    <!-- 使用thymeleaf解析 -->
    <bean id="templateResolver"
          class="org.thymeleaf.spring5.templateresolver.SpringResourceTemplateResolver">
        <property name="prefix" value="/WEB-INF/views/" />
        <property name="suffix" value=".html" />
        <property name="templateMode" value="HTML" />
        <property name="cacheable" value="false" />
    </bean>
    <bean id="shiroDialect" class="at.pollux.thymeleaf.shiro.dialect.ShiroDialect"/>
    <bean id="templateEngine" class="org.thymeleaf.spring5.SpringTemplateEngine">
        <property name="templateResolvers" ref="templateResolver" />
        <property name="additionalDialects" ref="shiroDialect" />
    </bean>
       <!-- 开启Shiro注解 start -->
    <bean id="lifecycleBeanPostProcessor" class="org.apache.shiro.spring.LifecycleBeanPostProcessor" />
    <!-- 开启Shiro注解 end -->
    <bean class="org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator" depends-on="lifecycleBeanPostProcessor" />
    <!-- 配置授权属性 -->
    <bean class="org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor">
        <property name="securityManager" ref="securityManager"></property>
    </bean>
</beans>
```

```xml
 <!--web.xml -->
 <!-- shiro filter start -->
  <filter>
    <filter-name>shiroFilter</filter-name>
    <filter-class>
      org.springframework.web.filter.DelegatingFilterProxy
    </filter-class>
    <init-param>
      <param-name>targetFilterLifecycle</param-name>
      <param-value>true</param-value>
    </init-param>
  </filter>
  <filter-mapping>
    <filter-name>shiroFilter</filter-name>
    <url-pattern>/*</url-pattern>
  </filter-mapping>
  <!-- shiro filter end -->
```

```java
package com.frame.modules.shiro;

import com.frame.modules.common.Constast;
import com.frame.modules.dao.PermissionMapper;
import com.frame.modules.dao.RoleMapper;
import com.frame.modules.dao.WorkerMapper;
import com.frame.modules.pojo.Worker;
import com.frame.modules.service.PermissionService;
import com.frame.modules.service.RoleService;
import com.frame.modules.service.WorkerService;
import org.apache.shiro.authc.*;
import java.util.Set;
import org.apache.shiro.authz.AuthorizationInfo;
import org.apache.shiro.authz.SimpleAuthorizationInfo;
import org.apache.shiro.realm.AuthorizingRealm;
import org.apache.shiro.subject.PrincipalCollection;
import org.springframework.beans.factory.annotation.Autowired;

public class MyRealm extends AuthorizingRealm{
    @Autowired
    private WorkerService workerService;
    @Autowired
    private RoleService roleService;
    @Autowired
    private PermissionService permissionService;


    public void setWorkerService(WorkerService workerService) {
        this.workerService = workerService;
    }
    /*用户授权类*/
    @Override
    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) {
        System.out.println("执行授权逻辑");
        //获取用户名
        String username = (String)principalCollection.iterator().next();
        //根据用户名获取用户角色
        Set<String> rolename = roleService.queryRoleNameByUserName(username);
        //根据用户名获取用户权限(set 可以去掉重复对象)
       Set<String> ps= permissionService.queryPermissionByUserName(username);
        //给资源进行授权
        SimpleAuthorizationInfo info = new SimpleAuthorizationInfo();
        info.setRoles(rolename);
        info.addStringPermissions(ps);
        return info;
    }

    /*用户认证类*/
    @Override
    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken arg0) throws AuthenticationException {
        System.out.println("用户认证开始");
        //编写shiro判断逻辑，判断用户名和密码
        //从token中获取用户名密码
        UsernamePasswordToken token = (UsernamePasswordToken) arg0;
        //从token中获取用户名
        String username = token.getUsername();
        //从token中获取密码
        char[] password = token.getPassword();
        //密码转字符串
        String pwd = password.toString();
        //匹配用户名
        Worker worker = workerService.findByUsernameAndUserpassword(username);

        //如果身份信息不正确则返回null,shiro会自动各跑出UnknownAccountException
        //用户名错误
        if(worker == null) {
            throw new UnknownAccountException();
        }else {
            worker.setLoginstatus("0");
        }
        //密码错误
        if(worker.getPassword() == pwd ){
            throw new IncorrectCredentialsException();
        }
        // 帐号锁定
        if (worker.getStatus() == Constast.Lock ) {
            throw new LockedAccountException();
        }
        //判断密码
        return new SimpleAuthenticationInfo(username, worker.getPassword(), getName());
    }

}

```

## 5.汉语转全拼

```java
import net.sourceforge.pinyin4j.PinyinHelper;
import net.sourceforge.pinyin4j.format.HanyuPinyinCaseType;
import net.sourceforge.pinyin4j.format.HanyuPinyinOutputFormat;
import net.sourceforge.pinyin4j.format.HanyuPinyinToneType;
import net.sourceforge.pinyin4j.format.HanyuPinyinVCharType;
import net.sourceforge.pinyin4j.format.exception.BadHanyuPinyinOutputFormatCombination;
import java.io.UnsupportedEncodingException;

public class ChineseCharToEnUtils {
    /**
     * 得到 全拼
     *
     * @param src
     * @return
     */
    public static String getPingYin(String src) {
        char[] t1 = null;
        t1 = src.toCharArray();
        String[] t2 = new String[t1.length];
        HanyuPinyinOutputFormat t3 = new HanyuPinyinOutputFormat();
        t3.setCaseType(HanyuPinyinCaseType.LOWERCASE);
        t3.setToneType(HanyuPinyinToneType.WITHOUT_TONE);
        t3.setVCharType(HanyuPinyinVCharType.WITH_V);
        String t4 = "";
        int t0 = t1.length;
        try {
            for (int i = 0; i < t0; i++) {
                // 判断是否为汉字字符
                if (java.lang.Character.toString(t1[i]).matches("[\\u4E00-\\u9FA5]+")) {
                    t2 = PinyinHelper.toHanyuPinyinStringArray(t1[i], t3);
                    t4 += t2[0];
                } else {
                    t4 += java.lang.Character.toString(t1[i]);
                }
            }
            return t4;
        } catch (BadHanyuPinyinOutputFormatCombination e1) {
            e1.printStackTrace();
        }
        return t4;
    }
    /**
     * 得到中文首字母
     *
     * @param str
     * @return
     */
    public static String getPinYinHeadChar(String str) {

        String convert = "";
        for (int j = 0; j < str.length(); j++) {
            char word = str.charAt(j);
            String[] pinyinArray = PinyinHelper.toHanyuPinyinStringArray(word);
            if (pinyinArray != null) {
                convert += pinyinArray[0].charAt(0);
            } else {
                convert += word;
            }
        }
        return convert;
    }

```

## 6.office转pdf接口

### 1.dcument4j

document4j不支持excel类型转换，并且只能在MS office环境中运行

```xml
<!--maven依赖convert doc-->
        <dependency>
            <groupId>com.documents4j</groupId>
            <artifactId>documents4j-local</artifactId>
            <version>1.0.3</version>
        </dependency>
        <dependency>
            <groupId>com.documents4j</groupId>
            <artifactId>documents4j-transformer-msoffice-word</artifactId>
            <version>1.0.3</version>
        </dependency>
```

```java
 /**
     * convert方法 接受参数 java.io.File 或 java.io.InputStream
     * to方法 接受参数 java.io.File 或 java.io.OutputStream
     *
     * @param sourceFile
     * @param tarPdfFile
     */
    public void toPdf(String sourceFile, String tarPdfFile,String realname,BufferedOutputStream water) {
        try {
            InputStream docxInputStream = new FileInputStream(sourceFile);
            OutputStream outputStream = new FileOutputStream(tarPdfFile);
            IConverter converter = LocalConverter.builder().build();
            converter.convert(docxInputStream).as(DocumentType.DOCX).to(outputStream).
                as(DocumentType.PDF).execute();
            outputStream.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
```

### 2.aspose

word转pdf需要引入 aspose-words-15.8.0-jdk16.jar

下载JAR包
Word
http://note.youdao.com/noteshare?id=1e73ab1c91abad338271d50a881165c2

excel转pdf需要引入aspose-cells-8.5.2.jar

Excel
http://note.youdao.com/noteshare?id=f75d87445106ea6ca6b54cfa58bc4fb2

```xml
  <dependency>
            <groupId>com.aspose</groupId>
            <artifactId>words</artifactId>
            <!--version，在本地跑项目时，不加不会报错，但是通过jenkins可持续集成构建时，需加version-->
            <!--version可以随便指定，因为下面指定了该依赖是从项目之中加载，不从maven仓库下载-->
            <!--jenkins可持续集成发布时，会更新依赖，若不指定version会报错-->
            <version>1.0</version>
            <scope>system</scope>
            <systemPath>${basedir}/src/main/resources/lib/aspose-words.jar</systemPath>
        </dependency>
        <dependency>
            <groupId>com.aspose</groupId>
            <artifactId>cells</artifactId>
            <version>1.0</version>
            <scope>system</scope>
            <systemPath>${basedir}/src/main/resources/lib/aspose-cells-8.5.2.jar</systemPath>
        </dependency>
 <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <configuration>
                <!-- 将项目本地依赖也打包在项目之中 -->
                    <includeSystemScope>true</includeSystemScope>
                </configuration>
            </plugin>
		</plugins>
</build>
```

```java
import java.io.File;
import java.io.FileOutputStream;
import java.io.InputStream;
 
import com.aspose.cells.Workbook;
import com.aspose.words.Document;
import com.aspose.words.License;
 
/**
* Word或Excel 转Pdf 帮助类
* @author lenovo
* 备注:需要引入 aspose-words-15.8.0-jdk16.jar / aspose-cells-8.5.2.jar
*/
public class PdfUtil {
 
    private static boolean getLicense() {
        boolean result = false;
       try {
           InputStream is = PdfUtil.class.getClassLoader().getResourceAsStream("license.xml"); // license.xml应放在..\WebRoot\WEB-INF\classes路径下
           License aposeLic = new License();
          aposeLic.setLicense(is);
          result = true;
       } catch (Exception e) {
         e.printStackTrace();
      }
     return result;
   }
 
   /**
  * @param wordPath 需要被转换的word全路径带文件名
  * @param pdfPath 转换之后pdf的全路径带文件名
  */
  public static void doc2pdf(String wordPath, String pdfPath) {
     if (!getLicense()) { // 验证License 若不验证则转化出的pdf文档会有水印产生
        return;
     }
    try {
        long old = System.currentTimeMillis();
        File file = new File(pdfPath); //新建一个pdf文档
        FileOutputStream os = new FileOutputStream(file);
        Document doc = new Document(wordPath); //Address是将要被转化的word文档
        doc.save(os, com.aspose.words.SaveFormat.PDF);//全面支持DOC, DOCX, OOXML, RTF HTML, OpenDocument, PDF, EPUB, XPS, SWF 相互转换
        long now = System.currentTimeMillis();
        os.close();
        System.out.println("共耗时：" + ((now - old) / 1000.0) + "秒"); //转化用时
        } catch (Exception e) {
            e.printStackTrace();
        }
     }

   /**
   * @param excelPath 需要被转换的excel全路径带文件名
   * @param pdfPath 转换之后pdf的全路径带文件名
   */
    public static void excel2pdf(String excelPath, String pdfPath) {
        if (!getLicense()) { // 验证License 若不验证则转化出的pdf文档会有水印产生
        return;
       }
      try {
         long old = System.currentTimeMillis();
        Workbook wb = new Workbook(excelPath);// 原始excel路径
        FileOutputStream fileOS = new FileOutputStream(new File(pdfPath));
        wb.save(fileOS, com.aspose.cells.SaveFormat.PDF);
        fileOS.close();
        long now = System.currentTimeMillis();
           System.out.println("共耗时：" + ((now - old) / 1000.0) + "秒"); //转化用时
        } catch (Exception e) {
          e.printStackTrace();
       }
     }
```

### 3.openoffice

需要启动openoffice服务才能运行

2.2.1的能转换doc ,但2.2.2才能转换docx,如果你用2.2.1的jar包,转换2.2.2的docx文档就会出

```shell
判断端口是否开启
netstat -ano -p tcp | find "8100" >nul 2>nul && echo 8100端口已开启 || echo 8100未开启

测试端口是否启动
telnet 127.0.0.1 8100

Windows启动openoffice服务
C:\Program Files (x86)\OpenOffice 4\program
soffice -headless -accept="socket,host=127.0.0.1,port=8100;urp;" -nofirststartwizard 
```

转换docx要的jar包

```
commons-cli-1.2.jar
commons-io-1.4.jar
cos.jar
DEPENDENCIES.txt
jodconverter-2.2.2.jar
jodconverter-cli-2.2.2.jar
juh-3.0.1.jar
jurt-3.0.1.jar
ridl-3.0.1.jar
slf4j-api-1.5.6.jar
slf4j-jdk14-1.5.6.jar
unoil-3.0.1.jar
xstream-1.3.1.jar
```

```java
     /**
     * 转换文件成pdf
     *
     * @param source: word文档
     * @param targe: pdf文档
     */
    public static void filepdf(String source, String targe) {
        File word = new File(source);
        File topdf = new File(targe);
        OpenOfficeConnection connection = new SocketOpenOfficeConnection("127.0.0.1",8100);
        try {
            connection.connect();
        } catch (ConnectException e) {
            System.err.println("aaa文件转换出错，请检查OpenOffice服务是否启动。");
        }
        // convert
        DocumentConverter converter = new OpenOfficeDocumentConverter(connection);
        System.out.println("bbb正在转换中……");
        converter.convert(word, topdf);
        connection.disconnect();
        System.out.println("ccc转换成功，服务已关闭");
    }
```



## 7.pdf自定义加水印接口

```xml
   <!-- https://mvnrepository.com/artifact/com.itextpdf/itext-asian -->
        <dependency>
            <groupId>com.itextpdf</groupId>
            <artifactId>itext-asian</artifactId>
            <version>5.2.0</version>
        </dependency>

        <!-- https://mvnrepository.com/artifact/com.itextpdf/itextpdf -->
        <dependency>
            <groupId>com.itextpdf</groupId>
            <artifactId>itextpdf</artifactId>
            <version>5.4.4</version>
        </dependency>
```



```java
 /**
     * 单行居中显示
     * @param bos 输出目录
     * @param input pdf原始目录
     * @param waterMarkName  水印标签
     * @throws DocumentException
     * @throws IOException
     */
    public static void setWatermark(BufferedOutputStream bos, String input, String waterMarkName)
            throws DocumentException, IOException {
        PdfReader reader = new PdfReader(input, "PDF".getBytes());
        PdfStamper stamper = new PdfStamper(reader, bos);
        int total = reader.getNumberOfPages() + 1;
        PdfContentByte content;
        BaseFont base = BaseFont.createFont("STSong-Light", "UniGB-UCS2-H", BaseFont.EMBEDDED);
        PdfGState gs = new PdfGState();
        for (int i = 1; i < total; i++) {
            // 在内容上方加水印
            content = stamper.getOverContent(i);
            //在内容下方加水印
            // content = stamper.getUnderContent(i);
            //水印透明度
            gs.setFillOpacity(0.5f);
            gs.setStrokeOpacity(0.5f);
            content.setGState(gs);
            content.beginText();
            content.setFontAndSize(base, 20);
            content.setTextMatrix(70, 200);
            //居中显示
            content.showTextAligned(Element.ALIGN_CENTER, waterMarkName, 320, 350, 55);
            content.endText();
        }
        stamper.close();

    }
```

```java
  /**
     *全屏显示
     * @param bos 输出目录
     * @param input pdf原始目录
     * @param waterMarkName  水印标签
     * @throws DocumentException
     * @throws IOException
     */
public static void setWatermark(BufferedOutputStream bos, String input, String waterMarkName)
            throws DocumentException, IOException {

        PdfReader reader = new PdfReader(input);
        PdfStamper stamper = new PdfStamper(reader, bos);

        // 获取总页数 +1, 下面从1开始遍历
        int total = reader.getNumberOfPages() + 1;
        // 使用classpath下面的字体库
        BaseFont base = null;
        try {
            //处理中文字体
            base = BaseFont.createFont("STSong-Light", "UniGB-UCS2-H",BaseFont.NOT_EMBEDDED);
        } catch (Exception e) {
            // 日志处理
            e.printStackTrace();
        }

        // 间隔
        int interval = -5;
        // 获取水印文字的高度和宽度
        int textH = 0, textW = 0;
        JLabel label = new JLabel();
        label.setText(waterMarkName);
        FontMetrics metrics = label.getFontMetrics(label.getFont());
        textH = metrics.getHeight();
        textW = metrics.stringWidth(label.getText());

        // 设置水印透明度
        PdfGState gs = new PdfGState();
        gs.setFillOpacity(0.5f);
        gs.setStrokeOpacity(0.5f);

        com.itextpdf.text.Rectangle pageSizeWithRotation = null;
        PdfContentByte content = null;
        for (int i = 1; i < total; i++) {
            // 在内容上方加水印
            content = stamper.getOverContent(i);
            // 在内容下方加水印
            // content = stamper.getUnderContent(i);
            content.saveState();
            content.setGState(gs);
            // 设置字体和字体大小
            content.beginText();
            content.setFontAndSize(base, 20);
            // 获取每一页的高度、宽度
            pageSizeWithRotation = reader.getPageSizeWithRotation(i);
            double pageHeight = pageSizeWithRotation.getHeight();
            double pageWidth = pageSizeWithRotation.getWidth();

            // 根据纸张大小多次添加， 水印文字成30度角倾斜
            for (int height = interval + textH; height < pageHeight; height = height + textH * 4) {
                for (int width = interval + textW; width < pageWidth + textW; width = width + textW * 2) {
                    content.showTextAligned(Element.ALIGN_LEFT, waterMarkName, width - textW, height - textH, 30);
                }
            }
            content.endText();
        }
        // 关流
        stamper.close();
        reader.close();

    }
```

## 8.当前访问用户的真实ip地址

可用于判断是否为内网或者操作权限

```java
    private static String isInside(HttpServletRequest request) {
        Boolean result = false;
        // 获取客户端IP地址，考虑反向代理的问题
        String ip = request.getHeader("x-forwarded-for");
        if (org.apache.commons.lang.StringUtils.isEmpty(ip) || "unknown".equalsIgnoreCase(ip)) {
            ip = request.getHeader("Proxy-Client-IP");
        }
        if (org.apache.commons.lang.StringUtils.isEmpty(ip) || "unknown".equalsIgnoreCase(ip)) {
            ip = request.getHeader("WL-Proxy-Client-IP");
        }
        if (org.apache.commons.lang.StringUtils.isEmpty(ip) || "unknown".equalsIgnoreCase(ip)) {
            ip = request.getRemoteAddr();
            if ("127.0.0.1".equals(ip) || "0:0:0:0:0:0:0:1".equals(ip)) {
                InetAddress inet = null;
                try {
                    inet = InetAddress.getLocalHost();
                    ip = inet.getHostAddress();
                } catch (UnknownHostException e) {
                    e.printStackTrace();
                }
            }
        }
        if (!org.apache.commons.lang.StringUtils.isEmpty(ip) && ip.length() > 15) {
            ip = ip.substring(0, ip.indexOf(","));
        }
        /*
         *  判断客户单IP地址是否为内网地址
         *  内网IP网段：
         *  10.0.0.0-10.255.255.255
         *  172.16.0.0-172.31.255.255
         *  192.168.0.0-192.168.255.255
         */
        String reg = "^(192\\.168|172\\.(1[6-9]|2\\d|3[0,1]))(\\.(2[0-4]\\d|25[0-5]|[0,1]?\\d?\\d)){2}$|^10(\\.([2][0-4]\\d|25[0-5]|[0,1]?\\d?\\d)){3}$";
        Pattern p = Pattern.compile(reg);
        Matcher matcher = p.matcher(ip);
        result = matcher.find();
        InetAddress a;
        try {
            a = InetAddress.getLocalHost();
            System.out.println("主机名称: " + a.getHostName()+"ip:"+ip);
            return result.toString()+"+"+a.getHostName()+"+"+ip;
        } catch (Exception e) {
            return null;
        }
    }
```

## 9.导出excel接口

### 基于EasyPOI导出excel

EasyPOI文档：http://easypoi.mydoc.io/#text_197817

```xml
 <!--==========================poi pom===============================-->
<dependency>
            <groupId>cn.afterturn</groupId>
            <artifactId>easypoi-base</artifactId>
            <version>4.1.3</version>
        </dependency>
        <dependency>
            <groupId>cn.afterturn</groupId>
            <artifactId>easypoi-web</artifactId>
            <version>4.1.3</version>
        </dependency>
        <dependency>
            <groupId>cn.afterturn</groupId>
            <artifactId>easypoi-annotation</artifactId>
            <version>4.1.3</version>
        </dependency>
        <dependency>
            <groupId>org.apache.poi</groupId>
            <artifactId>poi</artifactId>
            <version>3.14</version>
        </dependency>
        <dependency>
            <groupId>org.apache.poi</groupId>
            <artifactId>ooxml-schemas</artifactId>
            <version>1.4</version>
        </dependency>
```

```java
/**
*导出excel对应字段视图
**/
package com.tlcloud.oa.vo;
import cn.afterturn.easypoi.excel.annotation.Excel;
public class OaReimburseProjectVo  implements java.io.Serializable{

        @Excel(name = "单据编号", height = 20, width = 40)
        private String oraNo;

        @Excel(name = "付款类型", height = 20, width = 20)
        private String  oraApprovetype;

        @Excel(name = "项目编号",width=30)
        private String contractNo;

        @Excel(name = "项目名称",width=30)
        private   String  projectName;

        @Excel(name = "报销金额",width=30)
        private String  totalAmount;

        @Excel(name = "费用描述",width=30)
        private String  oradContent;

        @Excel(name = "发起人",width=20)
        private String  sponsor;

        @Excel(name = "发起时间",width=40)
        private String  createTime;
```

```java
/**
*导出excel工具类
**/
//获取字段对应列表
 List<OaReimburseProjectVo> list = oaReimburseApproveService.exportExcel(result);
        String exportPath = GlobelConfig.filedir_base + GlobelConfig.filedir_attachment;
        String df = DateUtil.format(new Date(),"yyyyMMddHHmmss");
        String exportName = df+"_费用关联项目表";
        Workbook workbook = ExcelExportUtil.exportExcel(new ExportParams(exportName, exportName), OaReimburseProjectVo.class, list);
        OutputStream out = null;
        try {
            out = new FileOutputStream(exportPath + File.separator + exportName + ".xlsx");
            workbook.write(out);
            return JSONUtils.result(true, 200, GlobelConfig.filedir_attachment + File.separator + exportName + ".xlsx");
        } catch (FileNotFoundException e) {
            e.printStackTrace();
            LogsUtils.error(getClass().getCanonicalName(), e);
            return JSONUtils.result(false, 500, e.getMessage());
        } catch (IOException e) {
            e.printStackTrace();
            LogsUtils.error(getClass().getCanonicalName(), e);
            return JSONUtils.result(false, 500, e.getMessage());
        } finally {
            IOUtils.closeQuietly(out);
            IOUtils.closeQuietly(workbook);
        }
```

### 使用JSON基于POI导出excel

```xml
     <!-- https://mvnrepository.com/artifact/org.apache.poi/poi -->
        <dependency>
            <groupId>org.apache.poi</groupId>
            <artifactId>poi</artifactId>
            <version>3.9</version>
        </dependency>

        <!-- https://mvnrepository.com/artifact/org.apache.poi/poi-ooxml -->
        <dependency>
            <groupId>org.apache.poi</groupId>
            <artifactId>poi-ooxml</artifactId>
            <version>3.9</version>
        </dependency>
```

```java
  /**
     * 导出excel工具类
     * @param exportName  导出的excel名
     * @param properWidth 设置excel合适的宽度，用于合理设置行高
     * @param jsonData  填充数据
     * @param maxLength1 key1：填充数据可能最多的第一个
     * @param maxLength2 key2：填充数据可能最多的第二个
     * @return
     */
    public static String exportRPExcelByJson(String exportName,Integer properWidth,String jsonData,String maxLength1,String maxLength2) {
        if (StringUtils.isNotBlank(jsonData)) {
            String exportPath = GlobelConfig.filedir_base + GlobelConfig.filedir_attachment;
            JSONObject jo = JSONObject.parseObject(jsonData);
            // 获取列头、数据对象
            JSONArray jaCols = jo.getJSONArray("cols");
            JSONArray jaData = jo.getJSONArray("data");
            try {
                // 第一步，创建一个webbook，对应一个Excel文件
                XSSFWorkbook wb = new XSSFWorkbook();
                // 第二步，在webbook中添加一个sheet,对应Excel文件中的sheet
                XSSFSheet sheet = wb.createSheet("Sheet");
                // 第三步，设置列宽
                for (int i = 0; i < jaCols.size(); i++) {
                    if(jaCols.getJSONObject(i).containsKey("width")){
                        sheet.setColumnWidth(i, 256*(Integer.valueOf(jaCols.getJSONObject(i).getString("width")))+184); //30左右
                    }
                }
                // 第四步，设置样式
                CellStyle titleStyle = wb.createCellStyle();
                CellStyle dataStyle = wb.createCellStyle();
                //文字垂直水平居中显示
                titleStyle.setAlignment(HSSFCellStyle.ALIGN_CENTER);
                dataStyle.setAlignment(HSSFCellStyle.ALIGN_CENTER);
                titleStyle.setVerticalAlignment(HSSFCellStyle.VERTICAL_CENTER);
                dataStyle.setVerticalAlignment(HSSFCellStyle.VERTICAL_CENTER);
                //设置表头背景色,yellow
                XSSFFont font = wb.createFont();
                font.setFontName("黑体");
                font.setBoldweight(HSSFFont.BOLDWEIGHT_BOLD);//粗体显示  
                titleStyle.setFont(font);
                //自动换行
                dataStyle.setWrapText(true);

                //第五步：填充表头
                XSSFRow row = sheet.createRow(0);

                for (int i = 0; i < jaCols.size(); i++) {
                    XSSFCell cell = row.createCell(i);
                    cell.setCellStyle(titleStyle);
                    cell.setCellValue(jaCols.getJSONObject(i).getString("title"));
                }
                // 填充数据
                for (int i = 0; i < jaData.size(); i++) {
                    row = sheet.createRow(i + 1);
                    int ja_content_length = 0;
                    int ja_title_length = 0;
                    if(StringUtils.isNotBlank(jaData.getJSONObject(i).getString(maxLength1))) {
                        ja_title_length = jaData.getJSONObject(i).getString(maxLength1).getBytes().length;
                    }
                    if(StringUtils.isNotBlank(jaData.getJSONObject(i).getString(maxLength2))){
                        ja_content_length = jaData.getJSONObject(i).getString(maxLength2).getBytes().length ;
                    }
                    int height = ja_content_length >= ja_title_length ? ja_content_length : ja_title_length;
                    int character_count = (properWidth/2)*3;
                    //被除数
                    BigDecimal bigDecimal =  new BigDecimal(height);
                    // 除数
                    BigDecimal divisor =  new  BigDecimal(character_count);
                    // 使用四舍五入模式，注意模式HALF_UP
                    MathContext mc =  new  MathContext(2, RoundingMode. HALF_UP);
                    Double lineCount = bigDecimal.divide(divisor, mc).doubleValue();
                    int convet = (int) Math.ceil(lineCount);//自动换行后行数向上取整
                    //经过调试，行高为自动换行后行数的30倍比较合适 ,POI行高默认单位为twips，1磅=20twips
                    int px = (convet * 30)*20; 
                    //自动适应行高
//                    XSSFRow xssfRow = sheet.getRow(i);
//                    CTRow ctRow = xssfRow.getCTRow();
//                    ctRow.setCustomHeight(false);
                    row.setHeight((short) px);
                    JSONObject obj = jaData.getJSONObject(i);
                    for (int j = 0; j < jaCols.size(); j++) {
                        XSSFCell cell = row.createCell(j);
                        cell.setCellStyle(dataStyle);
                        cell.setCellValue(obj.getString(jaCols.getJSONObject(j).getString("field")));
                    }
                }
                // 生成文件
                FileOutputStream fout =
                        new FileOutputStream(exportPath + File.separator + exportName + ".xlsx");
                wb.write(fout);
                fout.close();

                return JSONUtils.result(true, 200, GlobelConfig.filedir_attachment + File.separator + exportName + ".xlsx");
            } catch (Exception e) {
                LogsUtils.error(ExcelUtils.class.getCanonicalName(), e);

                return JSONUtils.result(false, 500, "异常错误:" + e.getMessage());
            }
        } else {
            return JSONUtils.result(false, 500, "获取不到数据");
        }
    }
```

```java
 // 导出例子
public Object exportList1(String oraNo, String contractNo, String projectName){
        Map<String, Object> result = new HashMap<>();
        result.put("oraNo", oraNo);
        result.put("contractNo", contractNo);
        result.put("projectName", projectName);
        List<OaReimburseProjectVo> list = oaReimburseApproveService.exportExcel(result);
        String df = DateUtil.format(new Date(),"yyyyMMddHHmmss");
        String exportName = df+"_费用关联项目表";
        // 组装表头
        JSONObject jsonObject = new JSONObject();
        List<JSONObject> jo_cols = new ArrayList<>();
        JSONObject jo_col_item = new JSONObject();
        jo_col_item.put("field", "oraNo");
        jo_col_item.put("align", "center");
        jo_col_item.put("title", "单据号");
        jo_col_item.put("width", 20);
        jo_cols.add(jo_col_item);
        jo_col_item = new JSONObject();
        jo_col_item.put("field", "oraApprovetype");
        jo_col_item.put("align", "center");
        jo_col_item.put("title", "付款类型");
        jo_col_item.put("width", 15);
        jo_cols.add(jo_col_item);
        jo_col_item = new JSONObject();
        jo_col_item.put("field", "contractNo");
        jo_col_item.put("align", "center");
        jo_col_item.put("title", "项目编号");
        jo_col_item.put("width", 20);
        jo_cols.add(jo_col_item);
        jo_col_item = new JSONObject();
        jo_col_item.put("field", "projectName");
        jo_col_item.put("align", "center");
        jo_col_item.put("title", "项目名称");
        jo_col_item.put("width", 60);
        jo_cols.add(jo_col_item);
        jo_col_item = new JSONObject();
        jo_col_item.put("field", "totalAmount");
        jo_col_item.put("align", "center");
        jo_col_item.put("title", "报销金额");
        jo_col_item.put("width", 15);
        jo_cols.add(jo_col_item);
        jo_col_item = new JSONObject();
        jo_col_item.put("field", "oradContent");
        jo_col_item.put("align", "center");
        jo_col_item.put("title", "费用描述");
        jo_col_item.put("width", 30);
        jo_cols.add(jo_col_item);
        jo_col_item = new JSONObject();
        jo_col_item.put("field", "sponsor");
        jo_col_item.put("align", "center");
        jo_col_item.put("title", "发起人");
        jo_col_item.put("width", 15);
        jo_cols.add(jo_col_item);
        jo_col_item = new JSONObject();
        jo_col_item.put("field", "createTime");
        jo_col_item.put("align", "center");
        jo_col_item.put("title", "发起时间");
        jo_col_item.put("width", 30);
        jo_cols.add(jo_col_item);
        jsonObject.put("cols", jo_cols);
        //填充数据
        JSONArray ja_data = new JSONArray();
        for(OaReimburseProjectVo oaReimburseProjectVo : list){
            JSONObject jo_data_item = new JSONObject();
            jo_data_item.put("oraNo",oaReimburseProjectVo.getOraNo());
            jo_data_item.put("oraApprovetype",oaReimburseProjectVo.getOraApprovetype());
            jo_data_item.put("contractNo",oaReimburseProjectVo.getContractNo());
            jo_data_item.put("projectName",oaReimburseProjectVo.getProjectName());
            jo_data_item.put("totalAmount",oaReimburseProjectVo.getTotalAmount());
            jo_data_item.put("oradContent",oaReimburseProjectVo.getOradContent());
            jo_data_item.put("sponsor",oaReimburseProjectVo.getSponsor());
            jo_data_item.put("createTime",oaReimburseProjectVo.getCreateTime());
            ja_data.add(jo_data_item);
        }
        jsonObject.put("data", ja_data);
        Gson gson = new Gson();
        String jsonData = gson.toJson(jsonObject);
        return ExcelUtils.exportRPExcelByJson(exportName,30,jsonData,"projectName","oradContent");
    }
```



# 前端模块功能

## 1.头像引用地址在线预览功能

```html
                <!--头像预览-->
                <div style="display:none" id="displayHead" class="displayHead">
                    <div class="user-info-head" >
                        <img id="header" src="" alt=""/>
                    </div>
                </div>
<div class="layui-form-item">
    <label class="layui-form-label layui-form-required">头像:</label>
     <div class="layui-input-inline" style="width: 400px">
     <input name="avatar"  placeholder="请使用正确的头像引用地址(url)" value="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=158071645,1972277985&fm=26&gp=0.jpg" class="layui-input" lay-verify="required" required/>
     </div>
    <!--点击跳转头像预览-->
<button class="layui-btn layui-btn-sm layui-btn-normal" id="display">头像预览</button >
  </div>
```

```js
 $('#display').on('click', function(data){
            layer.open({
                type: 1, //0（信息框，默认）1（页面层）2（iframe层）3（加载层）4（tips层）。
                title: false,
                anim: 5,
                area : ['120px' , '120px'],
                content:  $('#displayHead'),
                success:function () {
                    $("#header").attr("src",$('input[name=avatar]').val());
                }
            });
            return false;
        })
```

## 2.[layui]鼠标移入单元格自动显示所有信息

```js
done:function () {    
    $("td").on("mouseenter mouseover", function() {        
        if (this.offsetWidth < $(this).find("div")[0].scrollWidth) {         
            var that = this;           
            var text = $(this).text();           
            layer.tips(text, that, {             
                tips: [2,'#01AAED'],              
                icon:1,                
                time: 2000            
            }); }    });}
```